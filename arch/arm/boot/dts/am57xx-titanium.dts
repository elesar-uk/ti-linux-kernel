/*
 * Copyright (C) 2015 Elesar Ltd. - http://www.elesar.co.uk/
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
/dts-v1/;

#include "dra74x.dtsi"
#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/interrupt-controller/irq.h>

/ {
	model = "Elesar Titanium";
	compatible = "elesar,titanium", "ti,am5728", "ti,dra742", "ti,dra74", "ti,dra7";

	aliases {
		display0 = &dvi0;
		display1 = &dvi1;
		sound0 = &sound0;
		sound1 = &hdmi;
	};

	memory {
		device_type = "memory";
		reg = <0x80000000 0x80000000>; /* 2048 MB */
	};

	reserved-memory {
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		ipu2_cma_pool: ipu2_cma@95800000 {
			compatible = "shared-dma-pool";
			reg = <0x95800000 0x3800000>;
			reusable;
			status = "okay";
		};

		dsp1_cma_pool: dsp1_cma@99000000 {
			compatible = "shared-dma-pool";
			reg = <0x99000000 0x4000000>;
			reusable;
			status = "okay";
		};

		ipu1_cma_pool: ipu1_cma@9d000000 {
			compatible = "shared-dma-pool";
			reg = <0x9d000000 0x2000000>;
			reusable;
			status = "okay";
		};

		dsp2_cma_pool: dsp2_cma@9f000000 {
			compatible = "shared-dma-pool";
			reg = <0x9f000000 0x800000>;
			reusable;
			status = "okay";
		};
	};

	vdd_3v3: fixedregulator-sd {
		compatible = "regulator-fixed";
		regulator-name = "vdd_3v3";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
	};

	tfp410: encoder@0 {
		compatible = "ti,tfp410";

		ports {
			#address-cells = <1>;
			#size-cells = <0>;

			port@0 {
				reg = <0>;

				tfp410_in: endpoint@0 {
					remote-endpoint = <&dpi_out>;
				};
			};

			port@1 {
				reg = <1>;

				tfp410_out: endpoint@0 {
					remote-endpoint = <&dvi_connector_in>;
				};
			};
		};
	};

	dvi0: connector@0 {
		compatible = "dvi-connector";
		label = "dvi0";

		digital;

		ddc-i2c-bus = <&i2c4>;

		port {
			dvi_connector_in: endpoint {
				remote-endpoint = <&tfp410_out>;
			};
		};
	};

	/* The Titanium board does not actually have a TPD12S015 chip, but a
	 * placeholder encoder is required, so we pretend there is one and
	 * specify unconnected GPIO lines for 'CT CP HPD' and 'LS OE'. */
	tpd12s015: encoder@1 {
		compatible = "ti,tpd12s015";

		gpios = <&gpio7 1 GPIO_ACTIVE_HIGH>,	/* CT CP HPD: mmc3_dat2.gpio7_1 (unconnected) */
			<&gpio7 2 GPIO_ACTIVE_HIGH>,	/* LS OE: mmc3_dat3.gpio7_2 (unconnected) */
			<&gpio3 30 GPIO_ACTIVE_LOW>;	/* HPD: vin2a_fld0.gpio3_30 (VID1_E_HOTP) */

		ports {
			#address-cells = <1>;
			#size-cells = <0>;

			port@0 {
				reg = <0>;

				tpd12s015_in: endpoint@0 {
					remote-endpoint = <&hdmi_out>;
				};
			};

			port@1 {
				reg = <1>;

				tpd12s015_out: endpoint@0 {
					remote-endpoint = <&dvi1_connector_in>;
				};
			};
		};
	};

	dvi1: connector@1 {
		compatible = "dvi-connector";
		label = "dvi1";

		digital;

		ddc-i2c-bus = <&i2c5>;

		port {
			dvi1_connector_in: endpoint {
				remote-endpoint = <&tpd12s015_out>;
			};
		};
	};

	sound0: sound@0 {
		compatible = "ti,titanium-audio";
		ti,model = "Titanium";
		ti,always-on;
		ti,audio-codec = <&tlv320aic3107>;
		ti,mcasp-controller = <&mcasp3>;
		ti,codec-clock-rate = <5644800>;
		clocks = <&dpll_abe_ck>;
		clock-names = "mclk";
		ti,audio-routing =
			"Headphone Jack",	"HPLOUT",
			"Headphone Jack",	"HPROUT",
			"MIC3L",		"Mic Jack",
			"MIC3R",		"Mic Jack",
			"Mic Jack",		"Mic Bias",
			"LINE2L",		"Line In",
			"LINE2R",		"Line In";
	};

	gpio-poweroff {
		compatible = "gpio-poweroff";
		pinctrl-0 = <&power_off_pins>;
		pinctrl-names = "default";
		gpios = <&gpio7 7 GPIO_ACTIVE_HIGH>;
	};
};

&abe_dpll_sys_clk_mux {
	ti,parent = "sys_clkin1";
};

&dra7_pmx_core {
	/* Note that the addresses in 'pinctrl-single' definitions are */
	/* offsets from 0x0000 1400 (CTRL_CORE_PAD_GPMC_AD0) */

	dcan1_pins_default: dcan1_pins_default {
		pinctrl-single,pins = <
			0x3d0 (MUX_MODE0 | PIN_OUTPUT_PULLUP)	/* dcan1_tx.dcan1_tx (DCAN1_TX) */
			0x3d4 (MUX_MODE0 | PULL_UP)		/* dcan1_rx.dcan1_rx (DCAN1_RX) */
		>;
	};

	dcan1_pins_sleep: dcan1_pins_sleep {
		pinctrl-single,pins = <
			0x3d0 (MUX_MODE15 | PULL_UP)	/* dcan1_tx.safe (DCAN1_TX) */
			0x3d4 (MUX_MODE15 | PULL_UP)	/* dcan1_rx.safe (DCAN1_RX) */
		>;
	};

	mmc1_pins_default: pinmux_mmc1_default_pins {
		pinctrl-single,pins = <
			0x354 (MUX_MODE0 | PIN_OUTPUT)	/* mmc1_clk.mmc1_clk (MMC1_CLK) */
			0x358 (MUX_MODE0 | PIN_OUTPUT)	/* mmc1_cmd.mmc1_cmd (MMC1_CMD) */
			0x35c (MUX_MODE0 | PIN_INPUT)	/* mmc1_dat0.mmc1_dat0 (MMC1_DAT0) */
			0x360 (MUX_MODE0 | PIN_INPUT)	/* mmc1_dat1.mmc1_dat1 (MMC1_DAT1) */
			0x364 (MUX_MODE0 | PIN_INPUT)	/* mmc1_dat2.mmc1_dat2 (MMC1_DAT2) */
			0x368 (MUX_MODE0 | PIN_INPUT)	/* mmc1_dat3.mmc1_dat3 (MMC1_DAT3) */
			0x36c (MUX_MODE14 | PIN_INPUT)	/* mmc1_sdcd.gpio6_27 (MMC1_SDCD) */
		>;
	};

	mmc1_pins_hs: pinmux_mmc1_hs_pins {
		pinctrl-single,pins = <
			0x354 (MUX_MODE0 | MUX_VIRTUAL_MODE11 | PIN_OUTPUT)	/* mmc1_clk.mmc1_clk (MMC1_CLK) */
			0x358 (MUX_MODE0 | MUX_VIRTUAL_MODE11 | PIN_OUTPUT)	/* mmc1_cmd.mmc1_cmd (MMC1_CMD) */
			0x35c (MUX_MODE0 | MUX_VIRTUAL_MODE11 | PIN_INPUT)	/* mmc1_dat0.mmc1_dat0 (MMC1_DAT0) */
			0x360 (MUX_MODE0 | MUX_VIRTUAL_MODE11 | PIN_INPUT)	/* mmc1_dat1.mmc1_dat1 (MMC1_DAT1) */
			0x364 (MUX_MODE0 | MUX_VIRTUAL_MODE11 | PIN_INPUT)	/* mmc1_dat2.mmc1_dat2 (MMC1_DAT2) */
			0x368 (MUX_MODE0 | MUX_VIRTUAL_MODE11 | PIN_INPUT)	/* mmc1_dat3.mmc1_dat3 (MMC1_DAT3) */
			0x36c (MUX_MODE14 | PIN_INPUT)	/* mmc1_sdcd.gpio6_27 (MMC1_SDCD) */
		>;
	};

	power_off_pins: pinmux_power_off_pins {
		pinctrl-single,pins = <
			0x3a4 (MUX_MODE14 | PIN_OUTPUT)	/* spi1_sclk.gpio7_7 (GPIO_E_SOFTOFF) */
		>;
	};
};

&i2c1 {
	status = "okay";
	clock-frequency = <400000>;

	tps659038: tps659038@58 {
		compatible = "ti,tps659038";
		reg = <0x58>;

		/* The interrupt line is connected to gpio7_10, but it is
		 * not clear whether defining it like this is useful. */
		interrupt-parent = <&gpio7>;
		interrupts = <10 IRQ_TYPE_NONE>;

		tps659038_pmic {
			compatible = "ti,tps659038-pmic";

			regulators {
				smps12_reg: smps12 {
					/* VDD_MPU */
					regulator-name = "smps12";
					regulator-min-microvolt = < 850000>;
					regulator-max-microvolt = <1250000>;
					regulator-always-on;
					regulator-boot-on;
				};

				smps3_reg: smps3 {
					/* VDD_DDR */
					regulator-name = "smps3";
					regulator-min-microvolt = <1500000>;
					regulator-max-microvolt = <1500000>;
					regulator-always-on;
					regulator-boot-on;
				};

				smps45_reg: smps45 {
					/* VDD_DSPEVE, VDD_GPU, VDD_IVA */
					regulator-name = "smps45";
					regulator-min-microvolt = < 850000>;
					regulator-max-microvolt = <1150000>;
					regulator-always-on;
					regulator-boot-on;
				};

				smps6_reg: smps6 {
					/* VDD_CORE */
					regulator-name = "smps6";
					regulator-min-microvolt = <850000>;
					regulator-max-microvolt = <1060000>;
					regulator-always-on;
					regulator-boot-on;
				};

				/* SMPS7 unused */

				smps8_reg: smps8 {
					/* VDDS1V8 */
					regulator-name = "smps8";
					regulator-min-microvolt = <1800000>;
					regulator-max-microvolt = <1800000>;
					regulator-always-on;
					regulator-boot-on;
				};

				/* SMPS9 unused */

				ldo1_reg: ldo1 {
					/* LDO1_OUT --> SDIO  */
					regulator-name = "ldo1";
					regulator-min-microvolt = <1800000>;
					regulator-max-microvolt = <3300000>;
					regulator-boot-on;
				};

				ldo2_reg: ldo2 {
					/* Unused */
					regulator-name = "ldo2";
					regulator-min-microvolt = <3300000>;
					regulator-max-microvolt = <3300000>;
					regulator-boot-on;
				};

				ldo3_reg: ldo3 {
					/* VDDA_1V8_PHY */
					regulator-name = "ldo3";
					regulator-min-microvolt = <1800000>;
					regulator-max-microvolt = <1800000>;
					regulator-always-on;
					regulator-boot-on;
				};

				ldo9_reg: ldo9 {
					/* Unused */
					regulator-name = "ldo9";
					regulator-min-microvolt = <1050000>;
					regulator-max-microvolt = <1050000>;
					regulator-boot-on;
				};

				ldoln_reg: ldoln {
					/* VDDA_1V8_PLL */
					regulator-name = "ldoln";
					regulator-min-microvolt = <1800000>;
					regulator-max-microvolt = <1800000>;
					regulator-always-on;
					regulator-boot-on;
				};

				ldousb_reg: ldousb {
					/* VDDA_3V_USB: VDDA_USBHS33 */
					regulator-name = "ldousb";
					regulator-min-microvolt = <3300000>;
					regulator-max-microvolt = <3300000>;
					regulator-boot-on;
				};
			};
		};
	};

	encoder@38 {
		compatible = "ti,tfp410";
		reg = <0x38>;
	};

	tlv320aic3107: codec@18 {
		compatible = "ti,tlv320aic3106";
		reg = <0x18>;
		adc-settle-ms = <40>;
		ai3x-micbias-vg = <1>;	/* 2.0V */
		status = "okay";

		/* Regulators */
		AVDD-supply = <&vdd_3v3>;
		IOVDD-supply = <&vdd_3v3>;
		DRVDD-supply = <&vdd_3v3>;
		DVDD-supply = <&smps8_reg>;
	};

	eeprom@50 {
		compatible = "at24,24c16";
		reg = <0x50>;
		pagesize = <16>;
	};

	rtc@68 {
		compatible = "dallas,ds1338";
		reg = <0x68>;
	};
};

&i2c4 {
	status = "okay";
	clock-frequency = <400000>;
};

&i2c5 {
	status = "okay";
	clock-frequency = <400000>;
};

&uart1 {
	status = "okay";

	interrupts-extended = <&crossbar_mpu GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>,
			      <&dra7_pmx_core 0x3e0>;
};

&uart8 {
	status = "okay";
};

&mmc1 {
	status = "okay";

	pinctrl-names = "default", "hs";
	pinctrl-0 = <&mmc1_pins_default>;
	pinctrl-1 = <&mmc1_pins_hs>;

	vmmc-supply = <&vdd_3v3>;
	vmmc_aux-supply = <&ldo1_reg>;
	bus-width = <4>;
	cd-gpios = <&gpio6 27 0>;
	max-frequency = <96000000>;
};

&cpu0 {
	cpu0-voltdm = <&voltdm_mpu>;
	voltage-tolerance = <1>;
};

&voltdm_mpu {
	vdd-supply = <&smps12_reg>;
};

&voltdm_dspeve {
	vdd-supply = <&smps45_reg>;
};

&voltdm_gpu {
	vdd-supply = <&smps45_reg>;
};

&voltdm_ivahd {
	vdd-supply = <&smps45_reg>;
};

&voltdm_core {
	vdd-supply = <&smps6_reg>;
};

&qspi {
	status = "okay";

	spi-max-frequency = <48000000>;
	m25p80@0 {
		compatible = "winbond,w25q64";
		spi-max-frequency = <48000000>;
		reg = <0>;
		spi-tx-bus-width = <1>;
		spi-rx-bus-width = <4>;
		spi-cpol;
		spi-cpha;
		#address-cells = <1>;
		#size-cells = <1>;

		/* MTD partition table.
		 * The ROM checks the first four physical blocks
		 * for a valid file to boot and the flash here is
		 * 64KiB block size.
		 */
		partition@0 {
			label = "QSPI.SPL";
			reg = <0x00000000 0x000010000>;
		};
		partition@1 {
			label = "QSPI.SPL.backup1";
			reg = <0x00010000 0x00010000>;
		};
		partition@2 {
			label = "QSPI.SPL.backup2";
			reg = <0x00020000 0x00010000>;
		};
		partition@3 {
			label = "QSPI.SPL.backup3";
			reg = <0x00030000 0x00010000>;
		};
		partition@4 {
			label = "QSPI.u-boot";
			reg = <0x00040000 0x00100000>;
		};
		partition@5 {
			label = "QSPI.u-boot-spl-os";
			reg = <0x00140000 0x00080000>;
		};
		partition@6 {
			label = "QSPI.u-boot-env";
			reg = <0x001c0000 0x00010000>;
		};
		partition@7 {
			label = "QSPI.u-boot-env.backup1";
			reg = <0x001d0000 0x0010000>;
		};
		partition@8 {
			label = "QSPI.data";
			reg = <0x001e0000 0x0620000>;
		};
	};
};

&usb2_phy1 {
	phy-supply = <&ldousb_reg>;
};

&usb2_phy2 {
	phy-supply = <&ldousb_reg>;
};

&usb1 {
	dr_mode = "host";
};

&usb2 {
	dr_mode = "host";
};

&gpio7 {
	ti,no-reset-on-init;
	ti,no-idle-on-init;
};

&mac {
	status = "okay";
	dual_emac;
};

&cpsw_emac0 {
	phy_id = <&davinci_mdio>, <7>;
	phy-mode = "rgmii";
	dual_emac_res_vlan = <1>;
};

&cpsw_emac1 {
	phy_id = <&davinci_mdio>, <3>;
	phy-mode = "rgmii";
	dual_emac_res_vlan = <2>;
};

&davinci_mdio {
	phy3: ethernet-phy@3 {
		reg = <3>;
	};

	phy7: ethernet-phy@7 {
		reg = <7>;
	};
};

&dcan1 {
	status = "okay";
	pinctrl-names = "default", "sleep", "active";
	pinctrl-0 = <&dcan1_pins_sleep>;
	pinctrl-1 = <&dcan1_pins_sleep>;
	pinctrl-2 = <&dcan1_pins_default>;
};

&mcasp3 {
	#sound-dai-cells = <0>;

	status = "okay";

	op-mode = <0>;	/* MCASP_IIS_MODE */
	tdm-slots = <2>;

	/* 4 serializers */
	serial-dir = <	/* 0: INACTIVE, 1: TX, 2: RX */
		1 2 0 0
	>;
	tx-num-evt = <8>;
	rx-num-evt = <8>;
};

&dss {
	status = "okay";

	vdda_video-supply = <&ldoln_reg>;

	port {
		dpi_out: endpoint {
			remote-endpoint = <&tfp410_in>;
			data-lines = <24>;
		};
	};
};

&hdmi {
	status = "okay";

	vdda-supply = <&ldo3_reg>;

	port {
		hdmi_out: endpoint {
			remote-endpoint = <&tpd12s015_in>;
		};
	};
};

&mailbox5 {
	status = "okay";
	mbox_ipu1_ipc3x: mbox_ipu1_ipc3x {
		status = "okay";
	};
	mbox_dsp1_ipc3x: mbox_dsp1_ipc3x {
		status = "okay";
	};
};

&mailbox6 {
	status = "okay";
	mbox_ipu2_ipc3x: mbox_ipu2_ipc3x {
		status = "okay";
	};
	mbox_dsp2_ipc3x: mbox_dsp2_ipc3x {
		status = "okay";
	};
};

&mmu0_dsp1 {
	status = "okay";
};

&mmu1_dsp1 {
	status = "okay";
};

&mmu0_dsp2 {
	status = "okay";
};

&mmu1_dsp2 {
	status = "okay";
};

&mmu_ipu1 {
	status = "okay";
};

&mmu_ipu2 {
	status = "okay";
};

&ipu2 {
	status = "okay";
	memory-region = <&ipu2_cma_pool>;
	mboxes = <&mailbox6 &mbox_ipu2_ipc3x>;
	timers = <&timer3>;
	watchdog-timers = <&timer4>, <&timer9>;
};

&ipu1 {
	status = "okay";
	memory-region = <&ipu1_cma_pool>;
	mboxes = <&mailbox5 &mbox_ipu1_ipc3x>;
	timers = <&timer11>;
};

&dsp1 {
	status = "okay";
	memory-region = <&dsp1_cma_pool>;
	mboxes = <&mailbox5 &mbox_dsp1_ipc3x>;
	timers = <&timer5>;
};

&dsp2 {
	status = "okay";
	memory-region = <&dsp2_cma_pool>;
	mboxes = <&mailbox6 &mbox_dsp2_ipc3x>;
	timers = <&timer6>;
};

&rtc {
	status = "disabled";
};
